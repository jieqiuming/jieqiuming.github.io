<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
##异步编程

###一、场景
1. XMLHttpRequest请求
2. Web Worker

###二、常用解决方案
1. 嵌套回调函数调用
2. promise模式
##Promise

###一、状态
1. 未完成（unfulfilled）
2. 已完成（resolved）
3. 拒绝（rejected）

###二、CommonJS Promise/A标准
1. then方法  
1.1 负责添加针对已完成和拒绝状态下的处理函数  
1.2 返回另一个promise对象，形成promise管道，把异步操作串联起来  
1.3 then(resolvedHandler, rejectedHandler);
2. when方法  
2.1 处理多个ajax请求的并发协作,等到多个promise对象的状态发生变化后再做具体处理  
2.2 变种：when.some，when.all，when.any  
2.3 开源类库：when.js


##搭建Promise框架
###一、需要一些对象来存储promise

###二、定义then方法，接受两个参数用于处理完成和拒绝状态

###三、同时还需要两个方法来执行理从未完成到已完成（resolve）
和从未完成到拒绝（reject）的状态转变

###四、源码
``` 
var Promise = function () {
        /* initialize promise */
    };

Promise.prototype.then = function (onResolved, onRejected) {
     /* invoke handlers based upon state transition */
 };

Promise.prototype.resolve = function (value) {
     /* move from unfulfilled to resolved */
 };
 
 Promise.prototype.reject = function (error) {
     /* move from unfulfilled to rejected */
 };
```

##参考链接

1. [JavaScript异步编程的Promise模式](http://www.infoq.com/cn/news/2011/09/js-promise/)
2. [使用Jscex改善JavaScript异步编程体验](http://www.infoq.com/cn/articles/jscex-javascript-asynchronous-programming)
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<h2 id="">异步编程</h2>

<h3 id="">一、场景</h3>

<ol>
<li>XMLHttpRequest请求</li>
<li>Web Worker</li>
</ol>

<h3 id="">二、常用解决方案</h3>

<ol>
<li>嵌套回调函数调用</li>
<li>promise模式</li>
</ol>

<h2 id="promise">Promise</h2>

<h3 id="">一、状态</h3>

<ol>
<li>未完成（unfulfilled）</li>
<li>已完成（resolved）</li>
<li>拒绝（rejected）</li>
</ol>

<h3 id="commonjspromisea">二、CommonJS Promise/A标准</h3>

<ol>
<li>then方法 <br>
1.1 负责添加针对已完成和拒绝状态下的处理函数 <br>
1.2 返回另一个promise对象，形成promise管道，把异步操作串联起来 <br>
1.3 then(resolvedHandler, rejectedHandler);</li>
<li>when方法 <br>
2.1 处理多个ajax请求的并发协作,等到多个promise对象的状态发生变化后再做具体处理 <br>
2.2 变种：when.some，when.all，when.any <br>
2.3 开源类库：when.js</li>
</ol>

<h2 id="promise">搭建Promise框架</h2>

<h3 id="promise">一、需要一些对象来存储promise</h3>

<h3 id="then">二、定义then方法，接受两个参数用于处理完成和拒绝状态</h3>

<h3 id="resolve">三、同时还需要两个方法来执行理从未完成到已完成（resolve）</h3>

<p>和从未完成到拒绝（reject）的状态转变</p>

<h3 id="">四、源码</h3>

<pre><code class=" ">var Promise = function () {
        /* initialize promise */
    };

Promise.prototype.then = function (onResolved, onRejected) {
     /* invoke handlers based upon state transition */
 };

Promise.prototype.resolve = function (value) {
     /* move from unfulfilled to resolved */
 };

 Promise.prototype.reject = function (error) {
     /* move from unfulfilled to rejected */
 };
</code></pre>

<h2 id="">参考链接</h2>

<ol>
<li><a href="http://www.infoq.com/cn/news/2011/09/js-promise/">JavaScript异步编程的Promise模式</a></li>
<li><a href="http://www.infoq.com/cn/articles/jscex-javascript-asynchronous-programming">使用Jscex改善JavaScript异步编程体验</a></li>
</ol>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "promise.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
</body>
</html>
